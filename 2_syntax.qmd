# Syntax

### Assignment

R has a fancy assignment operator: `<-`.[^recitation-1] You assign things to a name by typing something like:

[^recitation-1]: Most other coding languages tend to use a boring `=` for assignment. Sure it's nice not having to type an extra character, but there's a keyboard shortcut to quickly add an `<-` in RStudio: Option/Alt + `-`. And philosophically, the `<-` arrow conveys the inherent directionality of the assignment operation. The object is assigned to the name; the object and its name are not equal and so the `=` arguably gives a misleading impression of the two things being one and the same. (Also, to let you in on a secret, `=` also works for assignment in R.)

```{r}
#| eval: false

name <- thing
```

The `thing` there might be a set of numbers, an entire dataset, or something else. Giving it a name allows to you perform subsequent operations more easily, and choosing appropriate names makes your code easier to understand.

```{r}
original_numbers <- 1:10
original_numbers

doubled_numbers <- original_numbers * 2
doubled_numbers
```

### Functions

Almost everything happens inside functions.

```{r}
mean(original_numbers)
mean(doubled_numbers)
```

You can also nest functions inside one another.

```{r}
sqrt(mean(original_numbers))
```

A function generally has one or more "arguments", to which you supply parameters. For example, the `mean()` function's first argument is the set of numbers you want to compute the mean of; in the previous examples `original_numbers` and `doubled_numbers` were the parameters I supplied. You don't necessarily have to type the name of the argument, but it can be helpful. The `seq()` function, for example, produces a sequence of numbers according to three arguments, `from`, `to`, and `by`.

```{r}
seq(from = 1, to = 10, by = 2)
```

When you don't type the names of the arguments, R matches them by position, so this gives exactly the same output as the previous line of code:

```{r}
seq(1, 10, 2)
```

You can get help with a function (to see what arguments it accepts, for example) by typing a question mark followed by the function name (without parentheses) in your console.

```{r}
#| eval: false
?mean
```

Running the code will bring up the function's help documentation in RStudio's Help pane.

### Piping

You can string together different operations in a pipeline using the pipe operator: `|>`.[^recitation-2] The result of each line of code gets "piped" into the function on the next line as its first argument. For example, below I take some data (named `my_data`) and perform a series of operations, first changing its shape using `pivot_longer()`, then creating summary statistics for the mean and standard deviation separately by a grouping-variable, then I pipe the summary statistics into `ggplot()` to create a graph with a `geom_col()` layer for the geometry.

[^recitation-2]: If you're looking at R code from elsewhere (e.g. looking up help online) you may see a different pipe: `%>%`. The `|>` pipe, called the "native" pipe, was only included as a feature of base R relatively recently. Until then, the `%>%` pipe was provided by an external package (called `magrittr`. [Get it?](https://magrittr.tidyverse.org/logo.png)). In practice the pipes work similarly, so you can often just replace `%>%` with `|>` and it'll work fine, but it's worth being aware of.

```{r}
#| include: false
library(ggplot2)
library(dplyr)
library(tidyr)
my_data <- data.frame(a = c(3, 3, 3),
                      b = c(5, 5, 5))
```

```{r}
my_data |> 
  pivot_longer(everything(),
               names_to = "condition",
               values_to = "score") |> 
  summarize(mean = mean(score),
            .by = condition) |> 
  ggplot(aes(x = condition, y = mean)) +
  geom_col()

```

Et voil√†, we have a serviceable graph of group means!

There's a lot going on there, and the specifics will become clearer as you work on the problem sets. But using the pipe operator this way can make for relatively readable code.
